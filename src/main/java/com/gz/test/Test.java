package com.gz.test;import com.google.gson.Gson;import java.text.SimpleDateFormat;import java.util.*;import java.util.concurrent.ExecutorService;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;import java.util.stream.Stream;import static java.util.concurrent.Executors.newFixedThreadPool;public class Test {    private static ExecutorService executorService = newFixedThreadPool(3);    public static void main(String[] args) throws Exception {        String pattern = "yyyy-MM-dd HH:mm:ss";        String source = "2020-10-23 21:57:31";        SimpleDateFormat format = new SimpleDateFormat(pattern);        Date date = new Date();        class AB implements TestInterface {            @Override            public void A() {            }            @Override            public void B() {            }        }        TestInterface testInterface = new TestInterface() {            @Override            public void A() {            }            @Override            public void B() {            }        };        TestInterface testInterface1 = new AB();        TestRunnable1 testRunnable1 = new TestRunnable1();        TestRunnable2 testRunnable2 = new TestRunnable2();        Thread thread1 = new Thread(testRunnable1);        Thread thread2 = new Thread(testRunnable2);       // executorService.submit(testRunnable1);        final List<String> baozi = new ArrayList<>();        baozi.add("韭菜鸡蛋");        baozi.add("三鲜猪肉");        final Object o = new Object();        Runnable runnable1 = new Runnable() {            @Override            public void run() {                while (true) {                    pl("要吃包子");                    synchronized (o) {                        try {                            o.wait();                            use();                        } catch (InterruptedException e) {                            e.printStackTrace();                            pl("asdasdasdasdasd");                        }                    }                }            }            void use() {                if (baozi.size() > 0) {                    baozi.forEach(str -> pl(Thread.currentThread().getName() + "吃了" + str));                }            }        };        Runnable runnable2 = new Runnable() {            @Override            public void run() {                while (true) {                    pl("-----------------");                    pl("开始做包子");                    try {                        Thread.sleep(2000);                        pl("做好了可以吃了");                        pl("-----------------");                        synchronized (o) {                            o.notify();                        }                        Thread.sleep(2000);                    } catch (InterruptedException e) {                        e.printStackTrace();                        pl("qweqweqweqweqwe");                    }                }            }        };        Thread thread3 = new Thread(runnable1);        Thread thread4 = new Thread(runnable2);        //Thread thread5 = new Thread(runnable3);        //thread3.start();        //thread5.start();        //thread4.start();        List<Person> personList = new ArrayList<>();        personList.add(new Person("a", 1, "男"));        personList.add(new Person("b", 3, "男"));        personList.add(new Person("c", 2, "男"));        personList.sort(((o1, o2) -> {            if (o1.age > o2.age) {                return 1;            } else if (o1.age == o2.age) {                return 0;            } else {                return -1;            }        }));        personList.stream().forEach(person -> System.out.println(person));        pl(personList);        String[] strings = {"a", "b"};        Stream<String> stringStream = Stream.of(strings);    }    static void exchange(int[] a, int min, int max) {        if (max <= min) {            return;        }        int temp = a[max];        a[max--] = a[min];        a[min++] = temp;        exchange(a, min, max);    }    public static <T> void pl(T t) {        System.out.println(t);    }    static class TestRunnable1 implements Runnable {        private int num = 100;        private final Lock lock = new ReentrantLock();        @Override        public void run() {            while (true) {                lock.lock();                try {                    if (num > 0) {                        pl(Thread.currentThread().getName() + "现在还剩 " + num-- + " 张票");                        Thread.sleep(10);                    } else {                        return;                    }                } catch (Exception e) {                    e.printStackTrace();                } finally {                    lock.unlock();                }            }        }    }    static class TestRunnable2 implements Runnable {        private final Lock lock = new ReentrantLock();        @Override        public void run() {            lock.lock();            try {                int q = 0;                for (int i = 1; i < 11; i++) {                    for (int j = 1; j < 11; j++) {                        pl(" " + q++);                        Thread.sleep(1000);                    }                    pl(" asdasd ");                }            } catch (Exception e) {                e.printStackTrace();            } finally {                lock.unlock();            }        }    }}